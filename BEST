#include <QTRSensors.h>

#define Kp 0.040 //0.055 yavaş ama her dönemeci döndü. 90 derecelerde sıkıntı var 0.065, 0.070 her yeri dönüyo  90 derecede ani tepki verip geri girmeye çalışıyo
#define Kd (Kp*0.33)
#define rightMaxSpeed 255
#define leftMaxSpeed 255
#define rightBaseSpeed 54// robot için kp ve kd değerlerini tutturduysanız şayet motorların dönmesi gereken hız budur
#define leftBaseSpeed 54// yukarıdaki değer ile aynıdır
#define leftMinSpeed 0
#define rightMinSpeed 0

#define rightMotor1 11
#define rightMotor2 12
#define rightMotorPWM 10
#define leftMotor1 8
#define leftMotor2 7
#define leftMotorPWM 9

QTRSensors qtr;
const uint8_t SensorCount = 8;
uint16_t sensorValues[SensorCount];



void setup()
{ 
  qtr.setTypeAnalog();
  qtr.setSensorPins((const uint8_t[]){A7, A6, A5, A4, A3, A2, A1, A0}, SensorCount);
  qtr.setEmitterPin(4);


  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(rightMotor1, OUTPUT);
  pinMode(rightMotor2, OUTPUT);
  pinMode(rightMotorPWM, OUTPUT);
  pinMode(leftMotor1, OUTPUT);
  pinMode(leftMotor2, OUTPUT);
  pinMode(leftMotorPWM, OUTPUT);

  delay(200);

  digitalWrite(LED_BUILTIN, HIGH);
  for (uint16_t i = 0; i < 200; i++)
  {
    qtr.calibrate();
  }
  digitalWrite(LED_BUILTIN, LOW);
  delay(1500);
}
int lastError = 0;

void loop()
{ uint16_t sensor1 = sensorValues[0];
  uint16_t sensor2 = sensorValues[1];
  uint16_t sensor3 = sensorValues[2];
  uint16_t sensor4 = sensorValues[3];
  uint16_t sensor5 = sensorValues[4];
  uint16_t sensor6 = sensorValues[5];
  uint16_t sensor7 = sensorValues[6];
  uint16_t sensor8 = sensorValues[7];   

  if ((sensor6 > 850) && (sensor7 > 850) && (sensor8 > 850)) {

  uint16_t position = qtr.readLineBlack(sensorValues);
  position = 7000;
    
  int error = position - 3500;
  int motorSpeed = Kp * error + Kd * (error - lastError);
  
  lastError = error;
  int rightMotorSpeed = rightBaseSpeed + motorSpeed;
  int leftMotorSpeed = leftBaseSpeed - motorSpeed;
  if (rightMotorSpeed > rightMaxSpeed ) rightMotorSpeed = rightMaxSpeed;
  if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
  if (rightMotorSpeed < rightMinSpeed) rightMotorSpeed = rightMinSpeed;
  if (leftMotorSpeed < leftMinSpeed) leftMotorSpeed = leftMinSpeed;
  
  digitalWrite(rightMotor1, HIGH);
  digitalWrite(rightMotor2, LOW);
  analogWrite(rightMotorPWM, rightMotorSpeed);

  digitalWrite(leftMotor1, HIGH);
  digitalWrite(leftMotor2, LOW);
  analogWrite(leftMotorPWM, leftMotorSpeed);
    }
  else { 
    
  uint16_t position = qtr.readLineBlack(sensorValues);
    
  int error = position - 3500;
  int motorSpeed = Kp * error + Kd * (error - lastError);
  
  lastError = error;
  int rightMotorSpeed = rightBaseSpeed + motorSpeed;
  int leftMotorSpeed = leftBaseSpeed - motorSpeed;
  if (rightMotorSpeed > rightMaxSpeed ) rightMotorSpeed = rightMaxSpeed;
  if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
  if (rightMotorSpeed < rightMinSpeed) rightMotorSpeed = rightMinSpeed;
  if (leftMotorSpeed < leftMinSpeed) leftMotorSpeed = leftMinSpeed;
  
  digitalWrite(rightMotor1, HIGH);
  digitalWrite(rightMotor2, LOW);
  analogWrite(rightMotorPWM, rightMotorSpeed);

  digitalWrite(leftMotor1, HIGH);
  digitalWrite(leftMotor2, LOW);
  analogWrite(leftMotorPWM, leftMotorSpeed);

  }
 

}
void wait() {
    digitalWrite(rightMotor1,LOW);
    digitalWrite(rightMotor2, LOW);
   

    digitalWrite(leftMotor1, LOW);
    digitalWrite(leftMotor2, LOW);

    delay(250);
}
