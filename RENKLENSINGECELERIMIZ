#include <QTRSensors.h>
#include <Arduino.h>


#define Kp 0.5
#define Kd (Kp*0.33)
#define Ki 0.00001
#define rightMaxSpeed 255
#define leftMaxSpeed 255
#define rightBaseSpeed 200// robot için kp ve kd değerlerini tutturduysanız şayet motorların dönmesi gereken hız budur
#define leftBaseSpeed 200// yukarıdaki değer ile aynıdır
#define leftMinSpeed 50
#define rightMinSpeed 50

#define rightMotor1 7
#define rightMotor2 8
#define rightMotorPWM 9
#define leftMotor1 11
#define leftMotor2 12
#define leftMotorPWM 10


volatile uint32_t pulseWidth;
uint32_t prevTime, currentTime, loopTime;

QTRSensors qtr;

const uint8_t SensorCount = 6;
uint16_t sensorValues[SensorCount];

void setup()
{
  qtr.setTypeAnalog();
  qtr.setSensorPins((const uint8_t[]){A1 ,A2 ,A3, A4, A5, A6}, SensorCount);
  qtr.setEmitterPin(4);

  delay(500);
  // analogRead() takes about 0.1 ms on an AVR.
  // 0.1 ms per sensor * 4 samples per sensor read (default) * 6 sensors
  // * 10 reads per calibrate() call = ~24 ms per calibrate() call.
  // Call calibrate() 400 times to make calibration take about 10 seconds.
  for (uint16_t i = 0; i < 300; i++)
  {
    qtr.calibrate();
  }
  
  pinMode(rightMotor1, OUTPUT);
  pinMode(rightMotor2, OUTPUT);
  pinMode(rightMotorPWM, OUTPUT);
  pinMode(leftMotor1, OUTPUT);
  pinMode(leftMotor2, OUTPUT);
  pinMode(leftMotorPWM, OUTPUT);

}

int lastError = 0;
void loop()
{
  currentTime = micros();
  loopTime = currentTime - prevTime;
  prevTime = currentTime;

  uint16_t position = qtr.readLineBlack(sensorValues);

  int error = position - 2500;
  int motorSpeed = Kp * error + Kd * (error - lastError)/(loopTime/1e6);
  
  lastError = error;
  int rightMotorSpeed = rightBaseSpeed + motorSpeed;
  int leftMotorSpeed = leftBaseSpeed - motorSpeed;
  if (rightMotorSpeed > rightMaxSpeed ) rightMotorSpeed = rightMaxSpeed;
  if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
  if (rightMotorSpeed < rightMinSpeed) rightMotorSpeed = rightMinSpeed;
  if (leftMotorSpeed < leftMinSpeed) leftMotorSpeed = leftMinSpeed;
  
    digitalWrite(rightMotor1, HIGH);
    digitalWrite(rightMotor2, LOW);
    analogWrite(rightMotorPWM, rightMotorSpeed);

    digitalWrite(leftMotor1, HIGH);
    digitalWrite(leftMotor2, LOW);
    analogWrite(leftMotorPWM, leftMotorSpeed);

}
void wait() {
    digitalWrite(rightMotor1,LOW);
    digitalWrite(rightMotor2, LOW);
   

    digitalWrite(leftMotor1, LOW);
    digitalWrite(leftMotor2, LOW);

    delay(250);
}
void turn_left() {
    digitalWrite(rightMotor1,HIGH);
    digitalWrite(rightMotor2, LOW);
    analogWrite (rightMotorPWM,rightBaseSpeed); 

    digitalWrite(leftMotor1, LOW);
    digitalWrite(leftMotor2, HIGH);
    analogWrite (leftMotorPWM,leftBaseSpeed);
}
void turn_right() {
    digitalWrite(rightMotor1,LOW);
    digitalWrite(rightMotor2, HIGH);
    analogWrite (rightMotorPWM,rightBaseSpeed);   

    digitalWrite(leftMotor1, HIGH);
    digitalWrite(leftMotor2, LOW);
    analogWrite (leftMotorPWM,leftBaseSpeed);    
}
